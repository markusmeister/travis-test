```{r, echo=FALSE}
if (!exists("headerloaded") || headerloaded==FALSE) {
  rmarkdown::render("Header.Rmd", quiet=TRUE)
  headerloaded = TRUE
}
```
# Figures

## Figures from image files

### JPG images
Insert the image using an R code chunk:

````markdown
`r ''````{r catdog, echo = FALSE, out.width='33%', fig.align='center', fig.cap = 'A JPG image of cat and dog'}
knitr::include_graphics(file.path(projdir, "img/catdog.jpg"))
```
````

```{r catdog, echo = FALSE, out.width='33%', fig.align='center', fig.cap = 'A JPG image of cat and dog'}
knitr::include_graphics(file.path(projdir, "img/catdog.jpg"))
```

Here `catdog` is the figure label. You can reference that label with the format `\@ref(fig:catdog)`: As seen in Fig. \@ref(fig:catdog) this seems to work.

### PDF images
For PDF images use the same method:

```{r diagram1, echo = FALSE, out.width='33%', fig.align='center', fig.cap ='A PDF image'}
knitr::include_graphics(file.path(projdir, "img/diagram1.pdf"))
```

The preview window in RStudio doesn't display the PDF image properly, but when viewing the HTML output in a browser it's OK.

### SVG images and Latex

To put SVG figures into PDF output requires a conversion. The function `include_svg` implements that, see [here](https://stackoverflow.com/questions/50165404/how-to-make-a-pdf-using-bookdown-including-svg-images). I put that function into the `Header.Rmd`.

This is an SVG image that includes Latex formatting:

````markdown
`r ''````{r SVG1, echo = FALSE, out.width='33%', fig.align='center', fig.cap = 'An SVG image'}
include_svg(file.path(projdir, "img/diagram2.svg"))
```
````

```{r SVG1, echo = FALSE, out.width='33%', fig.align='center', fig.cap = 'An SVG image'}
include_svg(file.path(projdir, "img/diagram2.svg"))
```

And an SVG with no Latex:

```{r SVG2, echo = FALSE, out.width='33%', fig.align='center', fig.cap = 'An SVG image'}
include_svg(file.path(projdir, "img/Ch_Figures/inkscape_drawing.svg"))
```

Both SVG files \@ref(fig:SVG1) and \@ref(fig:SVG2) look good in the HTML output. But \@ref(fig:SVG1) looks like crap in PDF. Something about how Latex gets represented in SVG? I got this result with SVGs produced by two different graphics programs. So for graphics that include Latex it's better to use a PDF file format.

## Figures from live Python code

We can use Python code blocks to generate figures in situ without going through a graphics file intermediate. Here is an example:

````markdown
`r ''````{python plotP0, echo = TRUE, out.width='33%', fig.align='center', fig.cap ='A plot from Python code'}
plt.plot([0, 2, 1, 4]);
```
````

```{python plotP0, echo = TRUE, out.width='33%', fig.align='center', fig.cap ='A plot from Python code'}
plt.plot([0, 2, 1, 4]);
```

As seen in Fig. \@ref(fig:plotP0) one can reference this as well.

## Using the mib plotting library {#mib-plotting-library}

I wrote some code for making the most common graphs and put it in a Python source file `mib/utils.py` in the project directory. The relevant functions are `plot()` and `save_img()`. They are imported as part of the `Header.Rmd`, so you have them available anytime. 

Here is how they work currently:

```
def plot(X, Y=None, xlabel=None, ylabel=None, legend=[], 
         xlim=None, ylim=None, xscale='linear', yscale='linear',
         xticks=None, yticks=None, yhide=False, yrot=False, yzero=False, 
         fmts=['g-', 'm--', 'b-.', 'r:'], linewidth=2, markersize=5, 
         grid=False, equal=False, figsize=(3,2), axes=None):
    """
    Plot data points.
    X: an array or list of arrays
    Y: an array or list of arrays
    If Y exists then those values are plotted vs the X values
    If Y doesn't exist the X values are plotted
    xlabel, ylabel: axis labels
    legend: list of labels for each Y series
    xlim, ylim: [low,high] list of limits for the 2 axes 
    xscale, yscale: 'linear' or 'log'
    xticks, yticks: list of locations for tick marks, or None for auto ticks
    yhide: hide the y axis?
    yrot: rotate the yaxis label to horizontal?
    yzero: zero line for the y-axis?
    fmts: a list of format strings to be applied to successive Y-series
    linewidth, markersize: obvious
    grid: draw a grid?
    equal: use equal aspect ratio, i.e. same scale per unit on x and y axis?
    figsize: (h,v) in inches
    axes: pre-existing axes where to draw the plot
    """
```

```
def save_img(imgname):
    """
    Saves the current plot to the img/ folder in the project directory
    """
```

For example,

```{python plotP1, echo = TRUE, out.width='66%', fig.align='center', fig.cap ='A plot using mib/utils.py'}
x = np.arange(-10,10,.01)
t = [0.1,0.3,1,3,10]
y = [np.exp(-x**2/(4*ti))/np.sqrt(4*np.pi*ti) for ti in t]
plot (x,y,fmts=['g-', 'm--', 'b-.', 'r:', 'k-'], linewidth=1,
    xlabel='Distance',ylabel='Concentration',yzero=True,
    legend=['t = 0.1','0.3','1','3','10'],xticks=[-10,-5,-1,0,1,5,10])
save_img('testplotP1.pdf')
plt.show()
```

In this case the image was saved to the `img/` directory, so you can retrieve it again later without recomputing, for example:

```{r plotP2, echo = TRUE, out.width='66%', fig.align='center', fig.cap ='A plot retrieved as an image file'}
knitr::include_graphics(file.path(projdir, "img/testplotP1.pdf"))
```

And of course you can cite both figures with the code labels, e.g. Figs. \@ref(fig:plotP1) and \@ref(fig:plotP2).

In the future, if we want to change something about the appearance of all our graphs, we can just edit the `plot()` function.
